import os
from SCons.Script import Import
import htmlmin
from jsmin import jsmin
import csscompressor

Import("env")

def minify_html_content(content):
    """Минификация HTML."""
    return htmlmin.minify(content, remove_comments=True, remove_empty_space=True)

def minify_js_content(content):
    """Минификация JavaScript."""
    return jsmin(content)

def minify_css_content(content):
    """Минификация CSS."""
    return csscompressor.compress(content)

def process_file(file_path):
    """Обработка файла в зависимости от расширения."""
    extension = os.path.splitext(file_path)[1].lower()
    try:
        with open(file_path, "rb") as file:
            binary_content = file.read()
    except UnicodeDecodeError:
        print(f"Error reading file {file_path}. Assuming binary content.")
        return binary_content

    # Обработка текстового содержимого в зависимости от расширения файла
    try:
        if extension in ['.html', '.htm']:
            return minify_html_content(binary_content.decode('utf-8')).encode('utf-8')
        elif extension in ['.js']:
            return minify_js_content(binary_content.decode('utf-8')).encode('utf-8')
        elif extension in ['.css']:
            return minify_css_content(binary_content.decode('utf-8')).encode('utf-8')
        else:
            return binary_content
    except UnicodeDecodeError:
        print(f"Error decoding file {file_path}. Skipping minimization.")
        return binary_content

def generate_resource_header(input_file, header_file, variable_name):
    """Генерация заголовочного файла для ресурса."""
    with open(input_file, "rb") as file:
        resource_content = file.read()

    hex_content = ', '.join(f'0x{byte:02x}' for byte in resource_content)
    content_length = len(resource_content)

    with open(header_file, "a", encoding="utf-8") as file:
        file.write(f'#ifndef {variable_name.upper()}_H\n#define {variable_name.upper()}_H\n\n')
        file.write(f'const uint8_t {variable_name}[] PROGMEM = {{{hex_content}}};\n')
        file.write(f'const size_t {variable_name}_len = {content_length};\n\n')
        file.write(f'#endif // {variable_name.upper()}_H\n\n')

def process_resources(resource_dir, output_file):
    """Обработка всех ресурсов."""
    resources = {
        "index.html": "indexHtml",
        "update.html": "updateHtml",
        "styles.css": "stylesCss",
        "script.js": "scriptJs",
        "favicon.ico": "faviconIco"
    }

    os.makedirs(os.path.dirname(output_file), exist_ok=True)

    with open(output_file, "w", encoding="utf-8") as file:
        file.write("// Autogenerated file for МикроББокс resources\n")
        file.write("#ifndef EMBEDDED_RESOURCES_H\n")
        file.write("#define EMBEDDED_RESOURCES_H\n\n")
        file.write("#include <Arduino.h>\n")
        file.write("#include <cstdint>\n\n")

    for resource, var_name in resources.items():
        input_file = os.path.join(resource_dir, resource)
        if os.path.isfile(input_file):
            minified_content = process_file(input_file)
            temp_minified_file = input_file + ".min"
            with open(temp_minified_file, "wb") as file:
                file.write(minified_content)
            generate_resource_header(temp_minified_file, output_file, var_name)
            os.remove(temp_minified_file)
        else:
            print(f"Resource file not found: {input_file}")
    
    with open(output_file, "a", encoding="utf-8") as file:
        file.write("#endif // EMBEDDED_RESOURCES_H\n")

def before_build_action(env):
    """Действие перед сборкой."""
    project_dir = env['PROJECT_DIR']
    resource_dir = os.path.join(project_dir, "resources")
    output_file = os.path.join(project_dir, "include", "embedded_resources.h")
    print(f"Embedding МикроББокс resources from {resource_dir} into {output_file}")
    if os.path.exists(resource_dir):
        process_resources(resource_dir, output_file)
    else:
        print(f"Resources directory not found: {resource_dir}")

before_build_action(env)