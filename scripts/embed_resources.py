import os
import subprocess
from SCons.Script import Import
import htmlmin
from jsmin import jsmin
import csscompressor

Import("env")

def get_firmware_version():
    """Получить версию прошивки из GIT_VERSION или git."""
    # Пытаемся получить из переменной окружения сборки
    git_version = env.get('GIT_VERSION', None)
    if git_version:
        return git_version
    
    # Пытаемся получить из git describe
    try:
        result = subprocess.run(['git', 'describe', '--tags', '--always', '--dirty'], 
                              capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            version = result.stdout.strip()
            if version:
                return version
    except Exception as e:
        print(f"Warning: Could not get git version: {e}")
    
    # Fallback
    return "v1.0.0-dev"

def substitute_placeholders(content, placeholders):
    """Заменить плейсхолдеры в контенте."""
    for key, value in placeholders.items():
        content = content.replace(f"__{key}__", value)
    return content

def minify_html_content(content):
    """Минификация HTML."""
    return htmlmin.minify(content, remove_comments=True, remove_empty_space=True)

def minify_js_content(content):
    """Минификация JavaScript отключена для сохранения UTF-8."""
    return content

def minify_css_content(content):
    """Минификация CSS отключена для сохранения UTF-8."""
    return content

def process_file(file_path, placeholders=None):
    """Обработка файла в зависимости от расширения."""
    if placeholders is None:
        placeholders = {}
    
    extension = os.path.splitext(file_path)[1].lower()
    try:
        with open(file_path, "rb") as file:
            binary_content = file.read()
    except UnicodeDecodeError:
        print(f"Error reading file {file_path}. Assuming binary content.")
        return binary_content

    # Обработка текстового содержимого в зависимости от расширения файла
    try:
        if extension in ['.html', '.htm']:
            text_content = binary_content.decode('utf-8')
            # Подставляем плейсхолдеры ПЕРЕД минификацией
            text_content = substitute_placeholders(text_content, placeholders)
            return minify_html_content(text_content).encode('utf-8')
        elif extension in ['.js']:
            text_content = binary_content.decode('utf-8')
            # Подставляем плейсхолдеры в JS тоже (могут быть в комментариях или константах)
            text_content = substitute_placeholders(text_content, placeholders)
            return minify_js_content(text_content).encode('utf-8')
        elif extension in ['.css']:
            text_content = binary_content.decode('utf-8')
            # Подставляем плейсхолдеры в CSS (могут быть в комментариях)
            text_content = substitute_placeholders(text_content, placeholders)
            return minify_css_content(text_content).encode('utf-8')
        else:
            return binary_content
    except UnicodeDecodeError:
        print(f"Error decoding file {file_path}. Skipping minimization.")
        return binary_content

def generate_resource_header(input_file, header_file, variable_name):
    """Генерация заголовочного файла для ресурса."""
    with open(input_file, "rb") as file:
        resource_content = file.read()

    hex_content = ', '.join(f'0x{byte:02x}' for byte in resource_content)
    content_length = len(resource_content)

    with open(header_file, "a", encoding="utf-8") as file:
        file.write(f'#ifndef {variable_name.upper()}_H\n#define {variable_name.upper()}_H\n\n')
        file.write(f'const uint8_t {variable_name}[] PROGMEM = {{{hex_content}}};\n')
        file.write(f'const size_t {variable_name}_len = {content_length};\n\n')
        file.write(f'#endif // {variable_name.upper()}_H\n\n')

def process_resources(resource_dir, output_file):
    """Обработка всех ресурсов."""
    resources = {
        "index.html": "indexHtml",
        "update.html": "updateHtml",
        "styles.css": "stylesCss",
        "script.js": "scriptJs",
        "favicon.ico": "faviconIco"
    }
    
    # Получаем версию прошивки
    firmware_version = get_firmware_version()
    print(f"Firmware version: {firmware_version}")
    
    # Создаем словарь плейсхолдеров для подстановки
    placeholders = {
        "VERSION": firmware_version
    }

    os.makedirs(os.path.dirname(output_file), exist_ok=True)

    with open(output_file, "w", encoding="utf-8") as file:
        file.write("// Autogenerated file for МикроББокс resources\n")
        file.write(f"// Firmware version: {firmware_version}\n")
        file.write("#ifndef EMBEDDED_RESOURCES_H\n")
        file.write("#define EMBEDDED_RESOURCES_H\n\n")
        file.write("#include <Arduino.h>\n")
        file.write("#include <cstdint>\n\n")

    for resource, var_name in resources.items():
        input_file = os.path.join(resource_dir, resource)
        if os.path.isfile(input_file):
            # Передаем плейсхолдеры в process_file
            minified_content = process_file(input_file, placeholders)
            temp_minified_file = input_file + ".min"
            with open(temp_minified_file, "wb") as file:
                file.write(minified_content)
            generate_resource_header(temp_minified_file, output_file, var_name)
            os.remove(temp_minified_file)
        else:
            print(f"Resource file not found: {input_file}")
    
    with open(output_file, "a", encoding="utf-8") as file:
        file.write("#endif // EMBEDDED_RESOURCES_H\n")

def before_build_action(env):
    """Действие перед сборкой."""
    project_dir = env['PROJECT_DIR']
    resource_dir = os.path.join(project_dir, "resources")
    output_file = os.path.join(project_dir, "include", "embedded_resources.h")
    print(f"Embedding МикроББокс resources from {resource_dir} into {output_file}")
    if os.path.exists(resource_dir):
        process_resources(resource_dir, output_file)
    else:
        print(f"Resources directory not found: {resource_dir}")

before_build_action(env)